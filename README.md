# Лабораторная работа №2
Алгоритмы и абстрактные структуры данных

## Задание 1. Стек
**Вариант 2**  
**Значение логического выражения**  
Задано логическое выражение. Необходимо вычислить его значение. В выражении могут встречаться знаки: `!` (отрицание), `&` (логическое «и»), `|` (логическое «или»), `^` (XOR — «исключающее ИЛИ», «ровно одно из двух — истина») и скобки. Самый высокий приоритет у отрицания, меньше — у `&`, операции `|` и `^` имеют самый низкий приоритет (одинаковый) и вычисляются слева направо. Все числа в выражении либо `0`, либо `1`.

## Задание 3. Множество
**Вариант 2**  
**Схожие подмножества**  
Необходимо реализовать алгоритм, который должен разбить множество натуральных чисел на непересекающиеся подмножества, разница между суммами которых была бы минимальна. Вывести получившиеся подмножества и разницу их сумм.

**Пример:**  
множество `S = {5, 8, 1, 14, 7}`.  
Получим два подмножества `{5, 14}` и `{8, 1, 7}`. Разница между их суммами - 3.

## Задание 4. Массив
**Вариант 2**  
**Поиск суммы**  
Необходимо реализовать алгоритм, который находит подмассив, сумма элементов которого равна заданному числу.

**Пример:**  
Массив `[4, -7, 1, 5, -4, 0, -3, 2, 4, 1]`, цель `5`.  
Подмассивы:  
`[5]`  
`[4, 1]`  
`[5, -4, 0, -3, 2, 4, 1]`  
`[1, 5, -4, 0, -3, 2, 4]`

## Задание 5. Двоичное дерево
**Вариант ***  
**Реализовать алгоритм Хаффмана.**  
Программа должна уметь преобразовать исходную строку в бинарный код и, наоборот, восстановить исходную строку из кода.

**Теоретическая информация.**  
Алгоритм Хаффмана – это алгоритм сжатия информации, основанный на частотах появления символов в сообщении и построении бинарного дерева поиска. Работает по следующему принципу:  
1. Вычисляются частоты появления каждого символа в сообщении. Частоты сортируются по убыванию.  
2. Строится список свободных узлов. Каждый узел содержит в себе символ и вес, равный частоте появления этого символа.  
3. Выбираются два узла с наименьшим весом.  
4. Создается родитель этих двух узлов, представляющий собой объединение их символов, с весом, равный сумме их весов.  
5. Сформированный узел добавляется в список свободных узлов вместо двух его узлов-потомков.  
6. Левой дуге, выходящей из родителя, присваивается бит `0`, а правой – бит `1`. Присвоение битов не зависит от весов потомков.  
7. Повторить шаги 3-6, пока в списке не останется один узел.

Таким образом, строится таблица символов, каждый из которых обладает уникальным бинарным кодом. Расшифрование кода Хаффмана происходит путем обхода дерева от корня до листьев, выбирая соответствующие битам дуги.

**Пример:**  
Вход: `abracadabra`  
Выход: `01110101000010010111010`  
Таблица:  
| a | b | r | c | d |
|---|---|---|---|---|
| 0 | 11 | 101 | 1000 | 1001 |

## Задание 6. Хеш-таблица
**Общее задание по вариантам**  
Реализовать хеш-таблицу.

**Вариант 2**  
**Двойное хеширование и Хеширование кукушки**  
Проведите эмпирический анализ хеширования двумя представленными методами, определите время выполнения `M` поисков при заданной последовательности `N` элементов.

**Вариант 2**  
**Реструктуризация**  
Реализуйте функцию реструктуризации хеш-таблицы в случае ее заполнения, а именно – когда таблица заполнена на 90%, создайте новую хеш-таблицу размером в два раза большим и передайте в нее все ключи. При этом для всех ключей выполняется повторное хеширование и повторная вставка в таблицу. Рекомендуется использовать библиотеку работы с большими числами.

## Задание 7. LRU/LFU
**Вариант 2**  
**LFU кэш**  
Разработайте структуру данных, которая работает как кэш LeastFrequentlyUsed. На вход подается запрос, который может быть двух типов:  
- `SET x y`: устанавливает значение ключа `x` со значением `y`. Если кэш достигает своей емкости, должен быть аннулирован элемент, к которому обращались реже всего.  
- `GET x`: возвращает ключ `x`, если он присутствует, иначе возвращает `-1`.  

В конструкторе класса должна быть инициализирована емкость кэша.

**Пример:**  
`cap` обозначает емкость кэша, а `Q` - количество запросов.  
`cap = 2, Q = 2`  
`Queries = SET(5,7) SET(4,6) SET(3,5) SET(2,4) SET(1,3) GET(1) GET(2) GET(3) GET(4) GET(5)`  
**Вывод:** `3 4 5 -1 -1`.  
При выполнении `SET(2,4)`, `(5,7)` становится недействительным.  
Аналогично, когда выполняется `SET(1,3)`, `(4,6)` становится недействительным.
